[gd_scene load_steps=3 format=2]

[ext_resource path="res://Actors/Enemies/Egg/Egg.tscn" type="PackedScene" id=1]

[sub_resource type="GDScript" id=1]

script/source = "extends Node

onready var actor = $Egg
var spawnPos = Vector2(0,0)

var dead_end = 0
var dead_cooldown = 10.0
var dead_confirmed = false
func startDeadCooldown():
	dead_end = global.clock + dead_cooldown
func isOnDeadCooldown():
	return global.clock < dead_end

var enemy_list = []

var get_agro_range = 750.0
var keep_agro_range = 1500.0
var swing_range = 150.0

var AIThread = Thread.new()
func _think(par):
	while(par.get_ref() and !par.get_ref().isDead()):
		var check_friendlies = _checkForStartCombat()
		var check_enemies = _antagonizeEnemy()
		var lost = []
		for e in enemy_list:
			if (_checkIsActor(e) and (_distanceTo(e) > keep_agro_range or e.isDead())):
				lost.append(e)
		for l in lost:
			enemy_list.erase(l)
		if (!actor.in_combat and enemy_list.size() > 0):
			actor.setInCombat(true)
			#TODO: any stuff that needs to be done when entering combat
		else: if (actor.in_combat and enemy_list.size() == 0):
			actor.setInCombat(false)
			#TODO: any stuff that needs to be done when exiting combat
		
		if (actor.in_combat):
			var decided = false
			var closest_e = null
			var closest_d = 999999.9
			for e in enemy_list:
				var dist = _distanceTo(e)
				if (dist < closest_d):
					closest_d = dist
					closest_e = e
				if (closest_d <= swing_range):
					actor.queueAbilityTowardsByName(\"Slam\", e.getPosition())
					decided = true
					break
			if (!decided and closest_e != null):
				actor.walkTowards(getPosition() + ((closest_e.getPosition() - getPosition()).normalized() * (closest_d - 1.2)))
			OS.delay_msec(50)
		else:
			actor.walkTowards(spawnPos + _randomPointInRadius(800))
			OS.delay_msec(1000)
	
	AIThread.call_deferred(\"wait_to_finish\")

func _antagonizeEnemy():
	for p in actor.world.Players.get_children():
		#TODO: check if sightline is free
		if (_checkIsActor(p) and get_agro_range >= _distanceTo(p)):
			p.setInCombat(true)
			if (!enemy_list.has(p)):
				enemy_list.append(p)
			return true
	return false

func _checkForStartCombat():
	for npc in actor.world.NPCs.get_children():
		if (_checkIsActor(npc) and get_agro_range >= _distanceTo(npc) and npc.isInCombat()): #TODO: check for visibily and alliedness
			for e in npc.enemy_list:
				if (!enemy_list.has(e)):
					enemy_list.append(e)
			return true
	return false

func _distanceTo(thing):
	return getPosition().distance_to(thing.getPosition())

func getState():
	#TODO: add AI state to gets, grab it from sets
	if (typeof(actor) != TYPE_NIL):
		return actor.getState()
	else:
		print(\"FAILED TO GET STATE \" + self.name)
		return null
func setState(state):
	if (typeof(actor) != TYPE_NIL):
		actor.setState(state)
	else:
		print(\"FAILED TO SET STATE \" + self.name)

func setSpawnPosition(pos):
	spawnPos = global.to2D(pos)

func isInCombat():
	return actor.in_combat

func getPosition():
	return actor.global_transform.origin

func isDead():
	return actor.is_dead

func _ready():
	randomize()
	actor.setPosition(spawnPos)
	var e = AIThread.start(self, \"_think\", weakref(self))
	print(e)

func _randomPointInRadius(rad):
	var vec = Vector2(0, randf() * rad)
	return vec.rotated(randf() * 2 * PI)

func _process(delta):
	if (dead_confirmed and !isOnDeadCooldown()):
		queue_free()
	else: if (!dead_confirmed and actor.is_dead):
		dead_confirmed = true
		startDeadCooldown()

func _checkIsActor(a):
	return a.has_method(\"getPosition\") and a.has_method(\"isInCombat\")"

[node name="Node" type="Node" index="0"]

script = SubResource( 1 )

[node name="Egg" parent="." index="0" instance=ExtResource( 1 )]


