[gd_scene load_steps=5 format=2]

[ext_resource path="res://Actors/Enemies/Egg/Assets/EggEnemy.dae" type="PackedScene" id=1]
[ext_resource path="res://Abilities/Enemy/Egg/Slam.tscn" type="PackedScene" id=2]

[sub_resource type="GDScript" id=1]

script/source = "extends \"res://Actors/Actor.gd\"

onready var slam_abil = $Abilities/Slam

onready var inventory_node = $Inventory

func _init():
	walk_speed = 1.0
	global_cooldown = 5.0

func getState():
	#get a state that you can regen the entierty of the actor from
	return {
		\"id\":self.name,
		\"global_cooldown_ends\":global_cooldown_ends,
		\"anim_cooldown_ends\":anim_cooldown_ends,
		\"in_combat\":in_combat,
		\"busy\":busy,
		\"is_attacking\":is_attacking,
		\"walk_speed\":walk_speed,
		\"pos\":get_global_position(),
		\"walk_towards\":walk_towards,
		\"walk_path\":walk_path,
		\"walk_dest\":walk_dest,
		\"current_wounds\":current_wounds,
		\"is_dead\":is_dead,
		\"defense\":defense,
		\"queued_ability_name\":queued_ability_name,
		\"queued_ability_point\":queued_ability_point,
		\"turn_dir\":turn_dir,
		\"playing_anim\":playing_anim,
		\"playing_anim_started\":playing_anim_started,
		}

func setState(state):
	#set all parameters of the actor, used to resync with server
	#TODO: optimize signal emission
	in_combat = state[\"in_combat\"]
	busy = state[\"busy\"]
	is_attacking = state[\"is_attacking\"]
	
	global_cooldown_ends = state[\"global_cooldown_ends\"]
	anim_cooldown_ends = state[\"anim_cooldown_ends\"]
	
	walk_speed = state[\"walk_speed\"]
	
	set_global_position(state[\"pos\"])
	walk_towards = state[\"walk_towards\"]
	walk_path = state[\"walk_path\"]
	walk_dest = state[\"walk_dest\"]
	
	current_wounds = state[\"current_wounds\"]
	defense = state[\"defense\"]
	is_dead = state[\"is_dead\"]
	emit_signal(\"damage_updated\")
	
	queued_ability_name = state[\"queued_ability_name\"]
	queued_ability_point = state[\"queued_ability_point\"]
	
	_turn_towards_direction(state[\"turn_dir\"])
	
	if (state[\"playing_anim\"] != null):
		_anim_playing(state[\"playing_anim\"], state[\"playing_anim_started\"])

func queueAbilityTowardsByName(abil_name, point):
	if (!busy):
		walk_towards = null
		pick_up = null
		
		queued_ability_point = point
		#TODO: add abilities to the egg
		#equipped_weapon.pointTowardsByName(abil_name, point) #TODO: make it depend on slot and whatever
		queued_ability_name = abil_name

func startTowardsByName(ability_name, point):
	# If we get more abilities on egg actually check passed name
	slam_abil.ability_user = weakref(self)
	slam_abil.startTowards(point)

func _ready():
	world = get_node(\"/root/World\")

func _process(delta):
	_updateModelPosition()
	#TODO: limit inputs when attacking
	if (!is_dead):
		#TODO: make the actor walk, interact, attack, and all that, client side based on parameters passed by controller
		if (walk_towards != null and !isOnGlobalCooldown()):
			if (in_combat):
				busy = true
			if (((walk_towards - global_transform.origin)).length() <= walk_speed * delta):
				translate((walk_towards - global_transform.origin))
				walk_towards = null
				if (walk_path != null and !walk_path.empty()):
					var walk3D = walk_path.pop_front()
					walk_towards = Vector2(walk3D.x, walk3D.z)
					_turn_towards(walk_towards)
				else:
					if (in_combat):
						startGlobalCooldown()
					busy = false
			else:
				translate((walk_towards - global_transform.origin).normalized() * walk_speed * delta)
		
		if (pick_up != null and pick_up.get_ref() and !pick_up.get_ref().on_ground):
			pick_up = null
		
		if (queued_ability_name != null and !isOnGlobalCooldown() and !busy):
			startTowardsByName(queued_ability_name, queued_ability_point)
			queued_ability_name = null
	
	#Make sure the right animation is playing
	if (!is_dead):
		if (!isOnAnimCooldown()):
			if (!is_attacking and walk_towards and !isOnGlobalCooldown()):
				_anim_playing(\"Walk\")
			else:
				if (in_combat):
					_anim_playing(\"Idle_combat\")
				else:
					_anim_playing(\"Idle\")
	else:
		_anim_playing(\"Death\")
"

[sub_resource type="CircleShape2D" id=2]

custom_solver_bias = 0.0
radius = 1.0

[node name="Egg" type="KinematicBody2D"]

input_pickable = false
collision_layer = 1
collision_mask = 1
collision/safe_margin = 0.08
script = SubResource( 1 )

[node name="CollisionShape2D" type="CollisionShape2D" parent="." index="0"]

scale = Vector2( 0.75, 0.75 )
shape = SubResource( 2 )
_sections_unfolded = [ "Transform" ]

[node name="Spatial" type="Spatial" parent="." index="1"]

[node name="Model" parent="Spatial" index="0" instance=ExtResource( 1 )]

[node name="Abilities" type="Node2D" parent="." index="2"]

_sections_unfolded = [ "Transform" ]

[node name="Slam" parent="Abilities" index="0" instance=ExtResource( 2 )]

_sections_unfolded = [ "Transform" ]


