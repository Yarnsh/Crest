[gd_scene load_steps=4 format=2]

[ext_resource path="res://Actors/Enemies/Egg/Assets/EggEnemy.dae" type="PackedScene" id=1]

[sub_resource type="GDScript" id=1]

script/source = "extends KinematicBody2D

var lock = Mutex.new()
func lock():
	lock.lock()
func unlock():
	lock.unlock()

var world
onready var spatial = $Spatial
onready var model = $Spatial/Model
onready var anim_player = $Spatial/Model/AnimationPlayer
onready var skeleton = $Spatial/Model/Armature/Skeleton

signal damage_updated

var highlight_count = 0

var turn_dir = Vector2(0,1)

var in_combat = false
var busy = false
var queued_ability_name = null
var queued_ability_point = Vector2(0,0)

onready var inventory_node = $Inventory

var is_attacking = false
var startup_ends = 0
var anim_cooldown_ends = 0
var attack_towards = null
func startAnimCooldown(anim_cooldown):
	anim_cooldown_ends = global.clock + anim_cooldown
func isOnAnimCooldown():
	return global.clock < anim_cooldown_ends

var pick_up = null

var walk_path = null
var walk_towards = null
var walk_dest = null

var max_wounds = [3,2,1]
var current_wounds = [0,0,0]
var defense = [2,10,20,40]
var is_dead = false

var walk_speed = 10.0

var playing_anim = null
var playing_anim_started = 0

var global_cooldown = 5.0
var global_cooldown_ends = 0
func startGlobalCooldown():
	global_cooldown_ends = global.clock + global_cooldown
func isOnGlobalCooldown():
	return global.clock < global_cooldown_ends

func toggleInCombat():
	in_combat = !in_combat

func setBusy(b):
	busy = b

func takeHit(damage):
	var damage_tier = -1
	while (defense[damage_tier+1] <= damage or (damage_tier >= 0 and current_wounds[damage_tier] >= max_wounds[damage_tier])):
		damage_tier += 1
		if (damage_tier >= max_wounds.size()):
			is_dead = true
			emit_signal(\"damage_updated\")
			return
	if (damage_tier >= 0):
		startAnimCooldown(1.0)
		_anim_playing(\"Damage\")
	current_wounds[damage_tier] += 1
	emit_signal(\"damage_updated\")

func addItem(id, type):
	var new_item = load(\"res://Items/\" + type + \".tscn\").instance()
	new_item.id = id
	new_item.set_name(new_item.id)
	inventory_node.add_child(new_item)
	inventory[id] = new_item
func destroyItem(id):
	var item = inventory_node.find_node(id)
	if (item != null):
		inventory_node.remove_child(item)
		inventory.erase(id)
		item.free()

func getState():
	#get a state that you can regen the entierty of the actor from
	var inv = {}
	for i in inventory:
		inv[i] = inventory[i].getState()
	
	var e_weapon = null
	if (equipped_weapon):
		e_weapon = equipped_weapon.id
	var e_chest = null
	if (equipped_chest):
		e_chest = equipped_chest.id
	var e_head = null
	if (equipped_head):
		e_head = equipped_head.id
	var e_arms = null
	if (equipped_arms):
		e_arms = equipped_arms.id
	var e_legs = null
	if (equipped_legs):
		e_legs = equipped_legs.id
	
	return {
		\"id\":self.name,
		\"global_cooldown_ends\":global_cooldown_ends,
		\"anim_cooldown_ends\":anim_cooldown_ends,
		\"in_combat\":in_combat,
		\"busy\":busy,
		\"is_attacking\":is_attacking,
		\"walk_speed\":walk_speed,
		\"pos\":get_global_position(),
		\"walk_towards\":walk_towards,
		\"walk_path\":walk_path,
		\"walk_dest\":walk_dest,
		\"current_wounds\":current_wounds,
		\"is_dead\":is_dead,
		\"defense\":defense,
		\"queued_ability_name\":queued_ability_name,
		\"queued_ability_point\":queued_ability_point,
		\"turn_dir\":turn_dir,
		\"playing_anim\":playing_anim,
		\"playing_anim_started\":playing_anim_started,
		}

func setState(state):
	#set all parameters of the actor, used to resync with server
	#TODO: optimize signal emission
	in_combat = state[\"in_combat\"]
	busy = state[\"busy\"]
	is_attacking = state[\"is_attacking\"]
	
	global_cooldown_ends = state[\"global_cooldown_ends\"]
	anim_cooldown_ends = state[\"anim_cooldown_ends\"]
	
	walk_speed = state[\"walk_speed\"]
	
	set_global_position(state[\"pos\"])
	walk_towards = state[\"walk_towards\"]
	walk_path = state[\"walk_path\"]
	walk_dest = state[\"walk_dest\"]
	
	current_wounds = state[\"current_wounds\"]
	defense = state[\"defense\"]
	is_dead = state[\"is_dead\"]
	emit_signal(\"damage_updated\")
	
	queued_ability_name = state[\"queued_ability_name\"]
	queued_ability_point = state[\"queued_ability_point\"]
	
	_turn_towards_direction(state[\"turn_dir\"])
	
	if (state[\"playing_anim\"] != null):
		_anim_playing(state[\"playing_anim\"], state[\"playing_anim_started\"])

func queueAbilityTowardsByName(abil_name, point):
	walk_towards = null
	pick_up = null
	
	queued_ability_point = point
	#TODO: add abilities to the egg
	#equipped_weapon.pointTowardsByName(abil_name, point) #TODO: make it depend on slot and whatever
	queued_ability_name = abil_name

func walkTowards(dest):
	#set current destination of this actor and make it walk
	queued_ability_name = null
	if (!busy):
		_walk(dest)
		pick_up = null

func _walk(dest):
	if (world != null):
		var close_dest = world.get_closest_point(Vector3(dest.x, 0, dest.y))
		walk_path = Array(world.get_simple_path(Vector3(transform.origin.x, 0, transform.origin.y), close_dest))
		var walk3D = walk_path.pop_front()
		walk_towards = Vector2(walk3D.x, walk3D.z)
		var walkDest3D = walk_path.back()
		walk_dest = Vector2(walkDest3D.x, walkDest3D.z)
	else:
		walk_towards = dest

func _turn_towards(point):
	var target = -point + (2 * get_global_position())
	turn_dir = (target - get_global_position()).normalized()
	if (get_global_position() != target):
		model.look_at(Vector3(target.x, 0.0 ,target.y), Vector3(0,1,0))
func _turn_towards_direction(dir):
	turn_dir = dir
	if (dir.length_squared() > 0.0):
		model.look_at(Vector3(get_global_position().x + dir.x, 0.0 ,get_global_position().y + dir.y), Vector3(0,1,0))

func startTowardsByName(ability_name, point):
	#TODO: make this work off egg abilities
	#if (equipped_weapon != null):
	#	equipped_weapon.startTowardsByName(self, ability_name, point)
	pass

func _updateModelPosition():
	var pos = get_position()
	spatial.transform.origin = Vector3(pos.x, 0, pos.y)
	#TODO: make this match to the height of the navmesh at that point
	for i in inventory_node.get_children():
		i.setGlobalPosition(pos)
	default_weapon.setGlobalPosition(pos)

func setHighlight(highlight):
	#TODO: make this not stupid like it is right now
	if (highlight):
		highlight_count += 1
	else:
		highlight_count -= 1
	if (highlight_count > 0):
		model.get_child(0).get_child(0).get_child(0).get_mesh().surface_get_material(0).set_next_pass(preload(\"res://highlightMat.tres\"))
	else:
		model.get_child(0).get_child(0).get_child(0).get_mesh().surface_get_material(0).set_next_pass(null)

func _anim_playing(anim, start_at = null):
	if (anim_player.get_current_animation() != anim):
		anim_player.play(anim)
		if (start_at != null):
			anim_player.seek(global.clock - start_at)
			playing_anim_started = start_at
		else:
			playing_anim_started = global.clock
		playing_anim = anim

func _ready():
	world = get_node(\"/root/World\")
	
	#Set all animations that need to to loop and vice versa
	for aname in anim_player.get_animation_list():
		anim_player.get_animation(aname).loop = false #Since if the default is loop or not seems random
	anim_player.get_animation(\"Idle\").loop = true
	anim_player.get_animation(\"Idle_Combat\").loop = true
	anim_player.get_animation(\"Run\").loop = true
	
	if (in_combat):
		_anim_playing(\"Idle_Combat\")
	else:
		_anim_playing(\"Idle\")

func _process(delta):
	_updateModelPosition()
	#TODO: limit inputs when attacking
	if (!is_dead):
		#TODO: make the actor walk, interact, attack, and all that, client side based on parameters passed by controller
		if (walk_towards != null and !isOnGlobalCooldown()):
			if (in_combat):
				busy = true
			if (((walk_towards - global_transform.origin)).length() <= walk_speed * delta):
				translate((walk_towards - global_transform.origin))
				walk_towards = null
				if (walk_path != null and !walk_path.empty()):
					var walk3D = walk_path.pop_front()
					walk_towards = Vector2(walk3D.x, walk3D.z)
					_turn_towards(walk_towards)
				else:
					if (in_combat):
						busy = false
						startGlobalCooldown()
			else:
				translate((walk_towards - global_transform.origin).normalized() * walk_speed * delta)
		
		if (pick_up != null and pick_up.get_ref() and !pick_up.get_ref().on_ground):
			pick_up = null
		
		if (queued_ability_name != null and !isOnGlobalCooldown()):
			startTowardsByName(queued_ability_name, queued_ability_point)
			queued_ability_name = null
	
	#Make sure the right animation is playing
	if (!is_dead):
		if (!isOnAnimCooldown()):
			if (!is_attacking and walk_towards and !isOnGlobalCooldown()):
				_anim_playing(\"Run\")
			else:
				if (in_combat):
					_anim_playing(\"Idle_Combat\")
				else:
					_anim_playing(\"Idle\")
	else:
		_anim_playing(\"Death\")
"

[sub_resource type="CircleShape2D" id=2]

custom_solver_bias = 0.0
radius = 1.0

[node name="Egg" type="KinematicBody2D" index="0"]

input_pickable = false
collision_layer = 1
collision_mask = 1
collision/safe_margin = 0.08
script = SubResource( 1 )

[node name="CollisionShape2D" type="CollisionShape2D" parent="." index="0"]

scale = Vector2( 0.75, 0.75 )
shape = SubResource( 2 )
_sections_unfolded = [ "Transform" ]

[node name="Spatial" type="Spatial" parent="." index="1"]

[node name="Model" parent="Spatial" index="0" instance=ExtResource( 1 )]


