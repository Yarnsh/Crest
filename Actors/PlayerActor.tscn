[gd_scene load_steps=8 format=2]

[ext_resource path="res://Actors/Assets/guy.png" type="Texture" id=1]
[ext_resource path="res://Actors/Assets/31.wav" type="AudioStream" id=2]
[ext_resource path="res://Actors/Assets/effect00.wav" type="AudioStream" id=3]
[ext_resource path="res://Items/FistItem.tscn" type="PackedScene" id=4]
[ext_resource path="res://Actors/Assets/Character.dae" type="PackedScene" id=5]

[sub_resource type="GDScript" id=1]

script/source = "extends Node2D

var lock = Mutex.new()
func lock():
	lock.lock()
func unlock():
	lock.unlock()

var world
onready var spatial = $Spatial
onready var model = $Spatial/Model
onready var anim_player = $Spatial/Model/AnimationPlayer

onready var SwingNoise = $SwingNoise
onready var HurtNoise = $HurtNoise

signal inventory_updated
signal equipment_updated

var highlight_count = 0

var in_combat = false
var busy = false
var queued_ability_name = null
var queued_ability_point = Vector2(0,0)

onready var inventory_node = $Inventory

onready var default_weapon = $DefaultWeapon
onready var equipped_weapon = default_weapon

var is_attacking = false
var startup_ends = 0
var attack_towards = null

var pick_up = null

var walk_path = null
var walk_towards = null
var walk_dest = null

var max_wounds = [3,2,1]
var current_wounds = [[],[],[]]
var defense = [2,10,20,40]
var is_dead = false
var health = 100 #TODO: replace with the wound system

var walk_speed = 10.0
var pick_up_range = 0.1
var inventory = {}

var global_cooldown = 5.0
var global_cooldown_ends = 0
func startGlobalCooldown():
	global_cooldown_ends = global.clock + global_cooldown
func isOnGlobalCooldown():
	return global.clock < global_cooldown_ends

func toggleInCombat():
	in_combat = !in_combat

func setBusy(b):
	busy = b

func takeHit(damage): #for testing atm
	HurtNoise.play()
	
	var damage_tier = -1
	while (defense[damage_tier+1] <= damage or (damage_tier >= 0 and current_wounds[damage_tier].size() >= max_wounds[damage_tier])):
		damage_tier += 1
		if (damage_tier >= max_wounds.size()):
			is_dead = true
			return
	current_wounds[damage_tier].append(1) #TODO: make this actual wounds of whatever type later

func addItem(id, type):
	var new_item = load(\"res://Items/\" + type + \".tscn\").instance()
	new_item.id = id
	new_item.set_name(new_item.id)
	inventory_node.add_child(new_item)
	inventory[id] = new_item
func destroyItem(id):
	var item = inventory_node.find_node(id)
	if (item != null):
		inventory_node.remove_child(item)
		inventory.erase(id)
		item.free()

func getState():
	#get a state that you can regen the entierty of the actor from
	var inv = {}
	for i in inventory:
		inv[i] = inventory[i].getState()
	
	return {
		\"id\":self.name,
		\"global_cooldown_ends\":global_cooldown_ends,
		\"in_combat\":in_combat,
		\"busy\":busy,
		\"is_attacking\":is_attacking,
		#TODO: make this work
		\"equipped_weapon\":equipped_weapon.name,
		\"default_weapon\":default_weapon.getState(),
		\"walk_speed\":walk_speed, 
		\"inventory\":inv, 
		\"pos\":get_global_position(),
		\"walk_towards\":walk_towards,
		\"walk_path\":walk_path,
		\"walk_dest\":walk_dest,
		\"current_wounds\":current_wounds,
		\"is_dead\":is_dead,
		\"defense\":defense,
		\"queued_ability_name\":queued_ability_name,
		\"queued_ability_point\":queued_ability_point,
		}

func setState(state):
	#set all parameters of the actor, used to resync with server
	in_combat = state[\"in_combat\"]
	busy = state[\"busy\"]
	is_attacking = state[\"is_attacking\"]
	
	global_cooldown_ends = state[\"global_cooldown_ends\"]
	
	walk_speed = state[\"walk_speed\"]
	
	for i in state[\"inventory\"]:
		if (inventory.has(i)):
			if (inventory[i].type != state[\"inventory\"][i][\"type\"]):
				destroyItem(i)
				addItem(i, state[\"inventory\"][i][\"type\"])
			inventory[i].setState(state[\"inventory\"][i])
		else:
			addItem(i, state[\"inventory\"][i][\"type\"])
			inventory[i].setState(state[\"inventory\"][i])
	emit_signal(\"inventory_updated\")
	
	var equipped_weapon_name = state[\"equipped_weapon\"]
	if (!equipped_weapon.name == equipped_weapon_name):
		if (equipped_weapon_name == default_weapon.name):
			unequipItem()
		else:
			equipItem(equipped_weapon_name)
		emit_signal(\"equipment_updated\")
	
	default_weapon.setState(state[\"default_weapon\"])
	
	set_global_position(state[\"pos\"])
	walk_towards = state[\"walk_towards\"]
	walk_path = state[\"walk_path\"]
	walk_dest = state[\"walk_dest\"]
	
	current_wounds = state[\"current_wounds\"]
	defense = state[\"defense\"]
	is_dead = state[\"is_dead\"]
	
	queued_ability_name = state[\"queued_ability_name\"]
	queued_ability_point = state[\"queued_ability_point\"]

func queueAbilityTowardsByName(abil_name, point):
	walk_towards = null
	pick_up = null
	
	queued_ability_point = point
	queued_ability_name = abil_name

func walkTowards(dest):
	#set current destination of this actor and make it walk
	#TODO: if in combat and on cooldown set this as a queued action
	#TODO: make this use navmesh path
	queued_ability_name = null
	if (!busy):
		_walk(dest)
		pick_up = null

func _walk(dest):
	anim_player.play(\"Run\")
	if (world != null):
		var close_dest = world.get_closest_point(Vector3(dest.x, 0, dest.y))
		walk_path = Array(world.get_simple_path(Vector3(transform.origin.x, 0, transform.origin.y), close_dest))
		var walk3D = walk_path.pop_front()
		walk_towards = Vector2(walk3D.x, walk3D.z)
		var walkDest3D = walk_path.back()
		walk_dest = Vector2(walkDest3D.x, walkDest3D.z)
	else:
		walk_towards = dest
	_turn_towards(walk_towards)

func _turn_towards(point):
	model.look_at(Vector3(point.x, 0.0 ,point.y), Vector3(0,1,0))

func pickUp(item):
	#TODO: check if item is able to be reached
	#TODO: ignore this in combat probably
	queued_ability_name = null
	if (item != null and !busy):
		pick_up = weakref(item)
		_walk(item.get_global_position())

func dropItem(id):
	if (inventory.has(id)):
		inventory_node.remove_child(inventory[id])
		world.Items.add_child(inventory[id])
		inventory[id].drop(get_global_position())
		inventory.erase(id)

func equipItem(id): #TODO: make this actually check what slot and shit is being done
	#TODO: dont allow any equipment changing during busy time
	#TODO: dont allow any equipment changing in combat
	if (inventory.has(id)):
		var item = inventory[id]
		if (item.slot == \"Weapon\"):
			#if (equipped_weapon != null and equipped_weapon.type == \"FistItem\"):
				#equipped_weapon = null
			#if (equipped_weapon != null):
				#inventory[equipped_weapon.id] = equipped_weapon
			equipped_weapon = item
			#inventory.erase(id)
			emit_signal(\"inventory_updated\")
			emit_signal(\"equipment_updated\")

func unequipItem(): #TODO: make this actually check what slot and shit is being done
	#TODO: dont allow changing weapons during busy time
	#TODO: dont allow any equipment changing in combat
	#if (equipped_weapon != null and equipped_weapon.type != \"FistItem\"):
		#inventory[equipped_weapon.id] = equipped_weapon
		equipped_weapon = default_weapon
		emit_signal(\"inventory_updated\")
		emit_signal(\"equipment_updated\")

func startTowardsByName(ability_name, point): #TODO: make this require which equipment the ability is from
	if (equipped_weapon != null):
		equipped_weapon.startTowardsByName(self, ability_name, point)

func _updateModelPosition():
	var pos = get_position()
	spatial.transform.origin = Vector3(pos.x, 0, pos.y)
	#TODO: make this match to the height of the navmesh at that point
	for i in inventory_node.get_children():
		i.setGlobalPosition(pos)
	default_weapon.setGlobalPosition(pos)

func setHighlight(highlight):
	#TODO: make this not stupid like it is right now
	if (highlight):
		highlight_count += 1
	else:
		highlight_count -= 1
	if (highlight_count > 0):
		model.get_child(0).get_child(0).get_child(0).get_mesh().surface_get_material(0).set_next_pass(preload(\"res://highlightMat.tres\"))
	else:
		model.get_child(0).get_child(0).get_child(0).get_mesh().surface_get_material(0).set_next_pass(null)

func _ready():
	world = get_node(\"/root/World\")
	
	#Set all animations that need to to loop
	anim_player.get_animation(\"Idle\").loop = true
	anim_player.get_animation(\"Idle_Combat\").loop = true
	anim_player.get_animation(\"Run\").loop = true
	
	if (in_combat):
		anim_player.play(\"Idle_Combat\")
	else:
		anim_player.play(\"Idle\")

func _process(delta):
	_updateModelPosition()
	#TODO: limit inputs when attacking
	if (!is_dead):
		if (!anim_player.is_playing()):
			if (in_combat):
				anim_player.play(\"Idle_Combat\")
			else:
				anim_player.play(\"Idle\")
		#TODO: make the actor walk, interact, attack, and all that, client side based on parameters passed by controller
		if (!is_attacking):
			if (walk_towards != null and !isOnGlobalCooldown()):
				if (in_combat):
					busy = true
				if (((walk_towards - global_transform.origin)).length() <= walk_speed * delta):
					translate((walk_towards - global_transform.origin))
					walk_towards = null
					if (walk_path != null and !walk_path.empty()):
						var walk3D = walk_path.pop_front()
						walk_towards = Vector2(walk3D.x, walk3D.z)
						_turn_towards(walk_towards)
					else:
						if (in_combat):
							anim_player.play(\"Idle_Combat\")
							busy = false
							startGlobalCooldown()
						else:
							anim_player.play(\"Idle\")
				else:
					translate((walk_towards - global_transform.origin).normalized() * walk_speed * delta)
			
			if (pick_up != null and pick_up.get_ref() and !pick_up.get_ref().on_ground):
				pick_up = null
			
			if (queued_ability_name != null and !isOnGlobalCooldown()):
				startTowardsByName(queued_ability_name, queued_ability_point)
				queued_ability_name = null
			
			#TODO: put on a lock on destructive item interactions like picking things up
			if (pick_up != null and pick_up.get_ref() and (pick_up.get_ref().getGlobalPosition() - global_transform.origin).length() < pick_up_range):
				inventory[pick_up.get_ref().id] = pick_up.get_ref()
				world.Items.remove_child(pick_up.get_ref())
				inventory_node.add_child(pick_up.get_ref())
				pick_up.get_ref().pickUp()
				pick_up = null
				emit_signal(\"inventory_updated\")
	else:
		get_node(\"Sprite\").set_texture(load(\"res://Actors/Assets/guyded.png\"))
"

[sub_resource type="CircleShape2D" id=2]

custom_solver_bias = 0.0
radius = 10.0

[node name="Actor" type="KinematicBody2D"]

input_pickable = true
collision_layer = 1
collision_mask = 1
collision/safe_margin = 0.08
script = SubResource( 1 )
_sections_unfolded = [ "Audio Bus", "Collision", "Pickable", "Transform" ]

[node name="Sprite" type="Sprite" parent="." index="0"]

texture = ExtResource( 1 )

[node name="CollisionShape2D" type="CollisionShape2D" parent="." index="1"]

show_behind_parent = true
scale = Vector2( 1.91537, 1.91537 )
shape = SubResource( 2 )
_sections_unfolded = [ "Material", "Transform", "Visibility" ]

[node name="HurtNoise" type="AudioStreamPlayer2D" parent="." index="2"]

stream = ExtResource( 2 )
volume_db = 0.0
autoplay = false
max_distance = 2000.0
attenuation = 1.0
bus = "Master"
area_mask = 1

[node name="SwingNoise" type="AudioStreamPlayer2D" parent="." index="3"]

stream = ExtResource( 3 )
volume_db = 0.0
autoplay = false
max_distance = 2000.0
attenuation = 1.0
bus = "Master"
area_mask = 1

[node name="DefaultWeapon" parent="." index="4" instance=ExtResource( 4 )]

_sections_unfolded = [ "Collision", "Transform" ]

[node name="Inventory" type="Node2D" parent="." index="5"]

[node name="Spatial" type="Spatial" parent="." index="6"]

[node name="Model" parent="Spatial" index="0" instance=ExtResource( 5 )]


