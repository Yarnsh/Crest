[gd_scene load_steps=8 format=2]

[ext_resource path="res://Actors/Assets/guy.png" type="Texture" id=1]
[ext_resource path="res://Actors/Assets/31.wav" type="AudioStream" id=2]
[ext_resource path="res://Actors/Assets/effect00.wav" type="AudioStream" id=3]
[ext_resource path="res://Items/FistItem.tscn" type="PackedScene" id=4]
[ext_resource path="res://Actors/Assets/Character.dae" type="PackedScene" id=5]

[sub_resource type="GDScript" id=1]

script/source = "extends Node2D

var lock = Mutex.new()
func lock():
	lock.lock()
func unlock():
	lock.unlock()

var world
onready var spatial = $Spatial
onready var model = $Spatial/Model
onready var anim_player = $Spatial/Model/AnimationPlayer
onready var skeleton = $Spatial/Model/Armature/Skeleton

onready var SwingNoise = $SwingNoise
onready var HurtNoise = $HurtNoise

signal inventory_updated
signal equipment_updated

var highlight_count = 0

var in_combat = false
var busy = false
var queued_ability_name = null
var queued_ability_point = Vector2(0,0)

onready var inventory_node = $Inventory

onready var default_weapon = $DefaultWeapon
onready var equipped_weapon = default_weapon
var equipped_chest = null
var equipped_head = null
var equipped_arms = null
var equipped_legs = null

var is_attacking = false
var startup_ends = 0
var attack_towards = null

var pick_up = null

var walk_path = null
var walk_towards = null
var walk_dest = null

var max_wounds = [3,2,1]
var current_wounds = [[],[],[]]
var defense = [2,10,20,40]
var is_dead = false
var health = 100 #TODO: replace with the wound system

var walk_speed = 10.0
var pick_up_range = 0.1
var inventory = {}

var global_cooldown = 5.0
var global_cooldown_ends = 0
func startGlobalCooldown():
	global_cooldown_ends = global.clock + global_cooldown
func isOnGlobalCooldown():
	return global.clock < global_cooldown_ends

func toggleInCombat():
	in_combat = !in_combat

func setBusy(b):
	busy = b

func takeHit(damage): #for testing atm
	HurtNoise.play()
	
	var damage_tier = -1
	while (defense[damage_tier+1] <= damage or (damage_tier >= 0 and current_wounds[damage_tier].size() >= max_wounds[damage_tier])):
		damage_tier += 1
		if (damage_tier >= max_wounds.size()):
			is_dead = true
			return
	current_wounds[damage_tier].append(1) #TODO: make this actual wounds of whatever type later

func addItem(id, type):
	var new_item = load(\"res://Items/\" + type + \".tscn\").instance()
	new_item.id = id
	new_item.set_name(new_item.id)
	inventory_node.add_child(new_item)
	inventory[id] = new_item
func destroyItem(id):
	var item = inventory_node.find_node(id)
	if (item != null):
		inventory_node.remove_child(item)
		inventory.erase(id)
		item.free()

func getState():
	#get a state that you can regen the entierty of the actor from
	var inv = {}
	for i in inventory:
		inv[i] = inventory[i].getState()
	
	var e_chest = null
	if (equipped_chest):
		e_chest = equipped_chest.name
	var e_head = null
	if (equipped_head):
		e_head = equipped_head.name
	var e_arms = null
	if (equipped_arms):
		e_arms = equipped_arms.name
	var e_legs = null
	if (equipped_legs):
		e_legs = equipped_legs.name
	
	return {
		\"id\":self.name,
		\"global_cooldown_ends\":global_cooldown_ends,
		\"in_combat\":in_combat,
		\"busy\":busy,
		\"is_attacking\":is_attacking,
		#TODO: make this work
		\"equipped_weapon\":equipped_weapon.name,
		\"default_weapon\":default_weapon.getState(),
		\"equipped_chest\":e_chest,
		\"equipped_head\":e_head,
		\"equipped_arms\":e_arms,
		\"equipped_legs\":e_legs,
		\"walk_speed\":walk_speed, 
		\"inventory\":inv, 
		\"pos\":get_global_position(),
		\"walk_towards\":walk_towards,
		\"walk_path\":walk_path,
		\"walk_dest\":walk_dest,
		\"current_wounds\":current_wounds,
		\"is_dead\":is_dead,
		\"defense\":defense,
		\"queued_ability_name\":queued_ability_name,
		\"queued_ability_point\":queued_ability_point,
		}

func setState(state):
	#set all parameters of the actor, used to resync with server
	#TODO: optimize signal emission
	in_combat = state[\"in_combat\"]
	busy = state[\"busy\"]
	is_attacking = state[\"is_attacking\"]
	
	global_cooldown_ends = state[\"global_cooldown_ends\"]
	
	walk_speed = state[\"walk_speed\"]
	
	for i in state[\"inventory\"]:
		if (inventory.has(i)):
			if (inventory[i].type != state[\"inventory\"][i][\"type\"]):
				destroyItem(i)
				addItem(i, state[\"inventory\"][i][\"type\"])
			inventory[i].setState(state[\"inventory\"][i])
		else:
			addItem(i, state[\"inventory\"][i][\"type\"])
			inventory[i].setState(state[\"inventory\"][i])
	emit_signal(\"inventory_updated\")
	
	var equipped_weapon_name = state[\"equipped_weapon\"]
	if (!equipped_weapon.name == equipped_weapon_name):
		if (equipped_weapon_name == default_weapon.name):
			unequipItem(\"Weapon\")
		else:
			equipItem(equipped_weapon_name)
		emit_signal(\"equipment_updated\")
	
	var equipped_chest_name = state[\"equipped_chest\"]
	if (!equipped_chest or !equipped_chest.name == equipped_chest_name):
		if (equipped_chest_name == null):
			unequipItem(\"Chest\")
		else:
			equipItem(equipped_chest_name)
		emit_signal(\"equipment_updated\")
	var equipped_head_name = state[\"equipped_head\"]
	if (!equipped_head or !equipped_head.name == equipped_head_name):
		if (equipped_head_name == null):
			unequipItem(\"head\")
		else:
			equipItem(equipped_head_name)
		emit_signal(\"equipment_updated\")
	var equipped_arms_name = state[\"equipped_arms\"]
	if (!equipped_arms or !equipped_arms.name == equipped_arms_name):
		if (equipped_arms_name == null):
			unequipItem(\"arms\")
		else:
			equipItem(equipped_arms_name)
		emit_signal(\"equipment_updated\")
	var equipped_legs_name = state[\"equipped_legs\"]
	if (!equipped_legs or !equipped_legs.name == equipped_legs_name):
		if (equipped_legs_name == null):
			unequipItem(\"legs\")
		else:
			equipItem(equipped_legs_name)
		emit_signal(\"equipment_updated\")
	
	default_weapon.setState(state[\"default_weapon\"])
	
	set_global_position(state[\"pos\"])
	walk_towards = state[\"walk_towards\"]
	walk_path = state[\"walk_path\"]
	walk_dest = state[\"walk_dest\"]
	
	current_wounds = state[\"current_wounds\"]
	defense = state[\"defense\"]
	is_dead = state[\"is_dead\"]
	
	queued_ability_name = state[\"queued_ability_name\"]
	queued_ability_point = state[\"queued_ability_point\"]

func queueAbilityTowardsByName(abil_name, point):
	walk_towards = null
	pick_up = null
	
	queued_ability_point = point
	queued_ability_name = abil_name

func walkTowards(dest):
	#set current destination of this actor and make it walk
	#TODO: if in combat and on cooldown set this as a queued action
	#TODO: make this use navmesh path
	queued_ability_name = null
	if (!busy):
		_walk(dest)
		pick_up = null

func _walk(dest):
	if (world != null):
		var close_dest = world.get_closest_point(Vector3(dest.x, 0, dest.y))
		walk_path = Array(world.get_simple_path(Vector3(transform.origin.x, 0, transform.origin.y), close_dest))
		var walk3D = walk_path.pop_front()
		walk_towards = Vector2(walk3D.x, walk3D.z)
		var walkDest3D = walk_path.back()
		walk_dest = Vector2(walkDest3D.x, walkDest3D.z)
	else:
		walk_towards = dest
	_turn_towards(walk_towards)

func _turn_towards(point):
	var target = -point + (2 * get_global_position())
	model.look_at(Vector3(target.x, 0.0 ,target.y), Vector3(0,1,0))

func pickUp(item):
	#TODO: check if item is able to be reached
	#TODO: ignore this in combat probably
	queued_ability_name = null
	if (item != null and !busy):
		pick_up = weakref(item)
		_walk(pick_up.get_ref().getGlobalPosition())

func dropItem(id):
	if (inventory.has(id)):
		if (equipped_weapon.id != id
		and (!equipped_chest or equipped_chest.id != id)):
			inventory_node.remove_child(inventory[id])
			world.Items.add_child(inventory[id])
			inventory[id].drop(get_global_position())
			inventory.erase(id)
			emit_signal(\"inventory_updated\")

func equipItem(id):
	#TODO: dont allow any equipment changing during busy time
	#TODO: dont allow any equipment changing in combat
	if (inventory.has(id)):
		var item = inventory[id]
		if (item.slot == \"Weapon\"):
			equipped_weapon = item
			#TODO: something about putting weapon in hand and also animations
		else: if (item.slot == \"Chest\"):
			equipped_chest = item
		else: if (item.slot == \"Head\"):
			equipped_head = item
		else: if (item.slot == \"Arms\"):
			equipped_arms = item
		else: if (item.slot == \"Legs\"):
			equipped_legs = item
		_setEquipmentModel(item.slot)
	
	emit_signal(\"inventory_updated\")
	emit_signal(\"equipment_updated\")

func unequipItem(type):
	#TODO: dont allow changing weapons during busy time
	#TODO: dont allow any equipment changing in combat
	if (type == \"Weapon\"):
		equipped_weapon = default_weapon
	else: if (type == \"Chest\"):
		equipped_chest = null
	else: if (type == \"Head\"):
		equipped_head = null
	else: if (type == \"Arms\"):
		equipped_arms = null
	else: if (type == \"Legs\"):
		equipped_legs = null
	_unsetEquipmentModel(type)
	emit_signal(\"inventory_updated\")
	emit_signal(\"equipment_updated\")

func _setEquipmentModel(type):
	_unsetEquipmentModel(type)
	var mesh
	if (type == \"Chest\" and equipped_chest):
		mesh = equipped_chest.mesh.duplicate()
		skeleton.get_node(\"BodyDefault\").hide()
	if (type == \"Head\" and equipped_head):
		mesh = equipped_head.mesh.duplicate()
		skeleton.get_node(\"HeadDefault\").hide()
	if (type == \"Arms\" and equipped_arms):
		mesh = equipped_arms.mesh.duplicate()
		skeleton.get_node(\"HandsDefault\").hide()
	if (type == \"Legs\" and equipped_legs):
		mesh = equipped_legs.mesh.duplicate()
		skeleton.get_node(\"LegsDefault\").hide()
	
	if (mesh):
		mesh.name = type
		skeleton.add_child(mesh)

func _unsetEquipmentModel(type):
	var mesh = skeleton.get_node(type)
	if (mesh):
		skeleton.remove_child(mesh)
		mesh.queue_free()
	
	if (type == \"Chest\"):
		skeleton.get_node(\"BodyDefault\").show()
	if (type == \"Head\"):
		skeleton.get_node(\"HeadDefault\").show()
	if (type == \"Arms\"):
		skeleton.get_node(\"HandsDefault\").show()
	if (type == \"Legs\"):
		skeleton.get_node(\"LegsDefault\").show()

func startTowardsByName(ability_name, point): #TODO: make this require which equipment the ability is from
	if (equipped_weapon != null):
		equipped_weapon.startTowardsByName(self, ability_name, point)

func _updateModelPosition():
	var pos = get_position()
	spatial.transform.origin = Vector3(pos.x, 0, pos.y)
	#TODO: make this match to the height of the navmesh at that point
	for i in inventory_node.get_children():
		i.setGlobalPosition(pos)
	default_weapon.setGlobalPosition(pos)

func setHighlight(highlight):
	#TODO: make this not stupid like it is right now
	if (highlight):
		highlight_count += 1
	else:
		highlight_count -= 1
	if (highlight_count > 0):
		model.get_child(0).get_child(0).get_child(0).get_mesh().surface_get_material(0).set_next_pass(preload(\"res://highlightMat.tres\"))
	else:
		model.get_child(0).get_child(0).get_child(0).get_mesh().surface_get_material(0).set_next_pass(null)

func _anim_playing(anim):
	if (anim_player.get_current_animation() != anim):
		anim_player.play(anim)

func _ready():
	world = get_node(\"/root/World\")
	
	#Set all animations that need to to loop
	anim_player.get_animation(\"Idle\").loop = true
	anim_player.get_animation(\"Idle_Combat\").loop = true
	anim_player.get_animation(\"Run\").loop = true
	
	if (in_combat):
		anim_player.play(\"Idle_Combat\")
	else:
		anim_player.play(\"Idle\")

func _process(delta):
	_updateModelPosition()
	#TODO: limit inputs when attacking
	if (!is_dead):
		#TODO: make the actor walk, interact, attack, and all that, client side based on parameters passed by controller
		if (!is_attacking):
			if (walk_towards != null and !isOnGlobalCooldown()):
				if (in_combat):
					busy = true
				if (((walk_towards - global_transform.origin)).length() <= walk_speed * delta):
					translate((walk_towards - global_transform.origin))
					walk_towards = null
					if (walk_path != null and !walk_path.empty()):
						var walk3D = walk_path.pop_front()
						walk_towards = Vector2(walk3D.x, walk3D.z)
						_turn_towards(walk_towards)
					else:
						if (in_combat):
							busy = false
							startGlobalCooldown()
				else:
					translate((walk_towards - global_transform.origin).normalized() * walk_speed * delta)
			
			if (pick_up != null and pick_up.get_ref() and !pick_up.get_ref().on_ground):
				pick_up = null
			
			if (queued_ability_name != null and !isOnGlobalCooldown()):
				startTowardsByName(queued_ability_name, queued_ability_point)
				queued_ability_name = null
			
			#TODO: put on a lock on destructive item interactions like picking things up
			if (pick_up != null and pick_up.get_ref() and (pick_up.get_ref().getGlobalPosition() - global_transform.origin).length() < pick_up_range):
				inventory[pick_up.get_ref().id] = pick_up.get_ref()
				world.Items.remove_child(pick_up.get_ref())
				inventory_node.add_child(pick_up.get_ref())
				pick_up.get_ref().pickUp()
				pick_up = null
				emit_signal(\"inventory_updated\")
	else:
		get_node(\"Sprite\").set_texture(load(\"res://Actors/Assets/guyded.png\"))
	
	#Make sure the right animation is playing
	if (!is_dead):
		if (is_attacking):
			pass #TODO: attack animations
		else: if (walk_towards and !isOnGlobalCooldown()):
			_anim_playing(\"Run\")
		else:
			if (in_combat):
				_anim_playing(\"Idle_Combat\")
			else:
				_anim_playing(\"Idle\")
	else:
		pass #TODO: dying animation
"

[sub_resource type="CircleShape2D" id=2]

custom_solver_bias = 0.0
radius = 10.0

[node name="Actor" type="KinematicBody2D"]

input_pickable = true
collision_layer = 1
collision_mask = 1
collision/safe_margin = 0.08
script = SubResource( 1 )
_sections_unfolded = [ "Audio Bus", "Collision", "Pickable", "Transform" ]

[node name="Sprite" type="Sprite" parent="." index="0"]

texture = ExtResource( 1 )

[node name="CollisionShape2D" type="CollisionShape2D" parent="." index="1"]

show_behind_parent = true
scale = Vector2( 1.91537, 1.91537 )
shape = SubResource( 2 )
_sections_unfolded = [ "Material", "Transform", "Visibility" ]

[node name="HurtNoise" type="AudioStreamPlayer2D" parent="." index="2"]

stream = ExtResource( 2 )
volume_db = 0.0
autoplay = false
max_distance = 2000.0
attenuation = 1.0
bus = "Master"
area_mask = 1

[node name="SwingNoise" type="AudioStreamPlayer2D" parent="." index="3"]

stream = ExtResource( 3 )
volume_db = 0.0
autoplay = false
max_distance = 2000.0
attenuation = 1.0
bus = "Master"
area_mask = 1

[node name="DefaultWeapon" parent="." index="4" instance=ExtResource( 4 )]

_sections_unfolded = [ "Collision", "Transform" ]

[node name="Inventory" type="Node2D" parent="." index="5"]

[node name="Spatial" type="Spatial" parent="." index="6"]

[node name="Model" parent="Spatial" index="0" instance=ExtResource( 5 )]


[editable path="Spatial/Model"]
